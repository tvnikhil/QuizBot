{
  "chunk-2633652c04fd22c7179333d8e36c173c": {
    "tokens": 1200,
    "content": "Page 1:\nNetwork Security\nIntroduction\nChapter 1\n\n\nPage 2:\nLearning Objective\n‚Ä¢ Introduce the security requirements \n‚Ä¢ confidentiality\n‚Ä¢ integrity\n‚Ä¢ availability\n‚Ä¢ Describe the X.800 security architecture for OSI \n\n\nPage 3:\nNetwork Security Requirements\n\n\nPage 4:\nComputer Network Security\n‚Ä¢ Definition: The protection afforded to an automated information \nsystem in order to attain the application objectives to preserving the \nintegrity, availability, and confidentiality of information system \nresources (includes hardware, software, firmware, information/data, \nand telecommunications).  \n- NIST Computer Security Handbook\n\n\nPage 5:\nConfidentiality\n‚Ä¢ Data confidentiality: Assures that private or confidential information \nis not made available or disclosed to unauthorized individuals; \n‚Ä¢ Privacy: Assures that individual's control or influence what \ninformation related to them may be collected and stored and by \nwhom and to whom that information may be disclosed\n‚Ä¢ i.e., student grade information\n\n\nPage 6:\nIntegrity\n‚Ä¢ Data integrity: Assures that data (both stored and in transmitted \npackets) and programs are changed only in a specified and authorized\nmanner;\n‚Ä¢ System integrity: Assures that a system performs its intended \nfunction in an unimpaired manner, free from deliberate or \ninadvertent unauthorized manipulation of the system\n‚Ä¢ i.e., a hospital patient‚Äôs allergy information  \n\n\nPage 7:\nAvailability\n‚Ä¢ Availability: Assures that systems work promptly, and service is not \ndenied to authorized users, ensuring timely and reliable access to and \nuse of information\n‚Ä¢ i.e., denial of service attack\n\n\nPage 8:\nOther security requirements\n‚Ä¢ Authenticity\n‚Ä¢ Accountability\n‚Ä¢ tracible data source, \n‚Ä¢ fault isolation\n‚Ä¢ intrusion detection and prevention, \n‚Ä¢ recovery and legal action\n‚Ä¢ system must keep records of their activities to permit later forensic analysis to \ntrace security breaches or to aid in transaction disputes\n\n\nPage 9:\nQuestion\n‚Ä¢ What security requirements does a blockchain system have achieved? \n\n\nPage 10:\nA Hyperledger\n\n\nPage 11:\nProject \n‚Ä¢ Task1: OnDemand Professor Q&A Bot \n‚Ä¢\nYour task is to build a Q&A Bot over private data that answers questions about the network security course using the open-source\nalternatives to ChatGPT that can be run on your local machine. Data privacy can be compromised when sending data over the internet, \nso it is mandatory to keep it on your local system. \n‚Ä¢\nYour Q&A Bot should be able to understand user questions and provide appropriate answers from the local database, then the citations \nshould be added (must be accomplished) if the response is from the internet, then the web references should be added. \n‚Ä¢\nTrain your bot using network security lecture slides, network security textbook, and the Internet. \n‚Ä¢\nBy using Wireshark capture data for Step 4's of the LLM workflow shown in Figure 1. Provide detailed explanations of the trace data. \nAlso, Maintain a record of Step 1's prompt and its mapping to the trace data in Step 4's.\n‚Ä¢ Task2: Quiz Bot \n‚Ä¢\nYour task is to build a quiz bot based on a network security course using the open-source alternatives to ChatGPT that can be run on \nyour local machine. Data privacy can be compromised when sending data over the internet, so it is mandatory to keep it on your local \nsystem. \n‚Ä¢\nTwo types of questions should be offered by the bot: randomly generated questions and specific topic questions and the answers should \nbe pulled from the network security database. Train your bot using network security quizzes, lecture slides, network security textbook, \nand the Internet. \n‚Ä¢\nThe quiz must include multiple-choice questions, true/false questions, and open-ended questions. \n‚Ä¢\nFinally, the bot should be able to provide feedback on the user's answers. \n\n\nPage 12:\n\n\nPage 13:\nOutline\n‚Ä¢ Review\n‚Ä¢ OSI Security Architecture\n‚Ä¢ Attack model \n\n\nPage 14:\nOSI Security Architecture\n\n\nPage 15:\nOSI Security Architecture\n‚Ä¢ International Telecommunication Union ‚Äì Telecommunication (ITU-T) \nrecommends X.800\n‚Ä¢ Security Architecture for Open Systems Interconnection (OSI)\n‚Ä¢ Defines a systematic way of defining and providing security requirements\n‚Ä¢ Used by IT managers and vendors in their products\nSecurity attacks\nSecurity mechanisms\nSecurity services\na process (or a device incorporating such a process) \nto detect, prevent, or recover from an attack\nenhances the security of the data processing \nsystems and the information transfers, such as \npolicies\n\n\nPage 16:\nOther Security Architectures\n‚Ä¢ NIST, Cybersecurity Framework (CSF)\n‚Ä¢ https://www.nist.gov/cyberframework\n‚Ä¢ VIRTUAL WORKSHOP #2 | February 15, 2023 (9:00 AM ‚Äì 5:30 PM EST). Discuss \npotential significant updates to the CSF \n‚Ä¢ https://www.nist.gov/news-events/events/2023/02/journey-nist-cybersecurity-\nframework-csf-20-workshop-2\n‚Ä¢ OWASP - Open Web Application Security Project\n‚Ä¢ Web application security\n‚Ä¢ OWASP Application Security Verification Standard (ASVS) -\nhttps://owasp.org/www-project-application-security-verification-standard/\n‚Ä¢ OWASP Web Security Testing - https://owasp.org/www-project-web-security-testing-\nguide/\n‚Ä¢ OWASP foundation\n\n\nPage 17:\nSecurity attack\n‚Ä¢ Definition: any action that compromises the security of information \nowned by an organization\n‚Ä¢ Two types of security attacks\n‚Ä¢ Passive attack\n‚Ä¢ Active attack\n\n\nPage 18:\nSecurity attack\n‚Ä¢ Definition: any action that compromises the security of information \nowned by an organization\n‚Ä¢ Two types of security attacks\n‚Ä¢ Passive attack\n‚Ä¢ Active attack\n\n\nPage 19:\nPassive attack\n‚Ä¢ i.e. eavesdropping on or monitoring of transmissions\n‚Ä¢ Goal:",
    "chunk_order_index": 0,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-7632e3d66823d987631ffd3afe5fca51": {
    "tokens": 1200,
    "content": "17:\nSecurity attack\n‚Ä¢ Definition: any action that compromises the security of information \nowned by an organization\n‚Ä¢ Two types of security attacks\n‚Ä¢ Passive attack\n‚Ä¢ Active attack\n\n\nPage 18:\nSecurity attack\n‚Ä¢ Definition: any action that compromises the security of information \nowned by an organization\n‚Ä¢ Two types of security attacks\n‚Ä¢ Passive attack\n‚Ä¢ Active attack\n\n\nPage 19:\nPassive attack\n‚Ä¢ i.e. eavesdropping on or monitoring of transmissions\n‚Ä¢ Goal: obtain information being transmitted\n‚Ä¢ release of message contents\n‚Ä¢ traffic analysis ‚Äì a promiscuous sniffer\n‚Ä¢ Very difficult to detect ‚Äì no alteration of the data\n‚Ä¢ But easy to prevent, why?\n\n\nPage 20:\nActive attack\n‚Ä¢ active attack includes:\n‚Ä¢ replay\n‚Ä¢ Modification of messages\n‚Ä¢ Denial of service\n‚Ä¢ Masquerade\n\n\nPage 21:\nExample: two points communication \n‚Ä¢ Generic types of attacks\nEavedropping\n\n\nPage 22:\nExample of modification attack in 6LoWPAN\n\n\nPage 23:\nExample: a group of attackers\n\n\nPage 24:\nKnow Your Threat Model\n‚Ä¢ Threat model: A model of who your attacker is and what resources \nthey have\n‚Ä¢ One of the best ways to counter an attacker is to attack their reasons\n\n\nPage 25:\nExample: adversary model\n‚Ä¢ ‚ÄúThe adversary is assumed to be intelligent and has \nlimited number of resources. Before capturing the \nnodes, it exploits the various vulnerabilities of the \nnetworks. It knows the topology of the network, \nrouting information. It aims to capture the sink node so \nas to disrupt the whole traffic. If it is not able to \ncapture the sink node, it will capture the nearby nodes \nof the sink. It tries to disrupt the whole traffic of the \nnetwork with minimum number of captured nodes. It is \nalso assumed that the adversary tends to attack more \non the nodes closer to the data sink than nodes that \nare far away‚Äù \n\n\nPage 26:\nNo class on Wednesday\n‚Ä¢ No class on Wednesday (Sept 18, 2024) due to the Job fair. Wish you \ngood luck!\n‚Ä¢ Reminder to form a project group by Sept. 9th, 2024\n\n\nPage 27:\nKnow Your Threat Model\n‚Ä¢ Threat model: A model of who your attacker is and what resources \nthey have\n‚Ä¢ One of the best ways to counter an attacker is to attack their reasons\n\n\nPage 28:\nStory‚Ä¶\n‚Ä¢ The bear race\n‚Ä¢ Takeaway: Even if a \ndefense is not perfect, it \nis important to always \nstay on top of best \nsecurity measures\nI don‚Äôt have to outrun the bear. I just have to outrun you\n\n\nPage 29:\nHuman Factors\n‚Ä¢ The users\n‚Ä¢ Users like convenience (ease of use)\n‚Ä¢ If a security system is unusable, it will be unused\n‚Ä¢ Users will find way to subvert security systems if it makes their lives easier\n‚Ä¢ The programmers\n‚Ä¢ Programmers make mistakes\n‚Ä¢ Programmers use tools that allow them to make mistakes (e.g. C and C++)\n‚Ä¢ Everyone else\n‚Ä¢ Social engineering attacks exploit other people‚Äôs trust and access for personal \ngain\n\n\nPage 30:\nDesign in security from the start\n‚Ä¢ When building a new system, include security as part of the design \nconsiderations rather than patching it after the fact\n‚Ä¢ A lot of systems today were not designed with security from the start, \nresulting in patches that don‚Äôt fully fix the problem!\n‚Ä¢ Keep these security principles in mind whenever you write code!\n\n\nPage 31:\nSecurity Services and Mechanisms\n\n\nPage 32:\nSupplementary materials\n‚Ä¢ Internet Security Glossary, v2 ‚Äì produced by Internet Society (ISOC) \nhttps://datatracker.ietf.org/doc/html/rfc4949\n‚Ä¢ X.800 ‚Äì OSI network security\nhttps://www.itu.int/rec/dologin_pub.asp?lang=f&id=T-REC-X.800-\n199103-I!!PDF-E&type=items\n\n\nPage 33:\nSummary for Chapter 1\n‚Ä¢ Have learned:\n‚Ä¢ Security requirements\n‚Ä¢ Attack models\n‚Ä¢ X.800 secure architecture, security services, mechanisms\n\n\nPage 34:\nReview Questions\n‚Ä¢ William Stallings (WS), ‚ÄúNetwork Security \nEssentials‚Äù, 6th Global Edition\n‚Ä¢ RQ 1.1 - 1.3\n‚Ä¢ Prob 1.5\n\n\nPage 35:\nSymmetric Encryption and Message Confidentiality\nChapter 2\n\n\nPage 36:\nModel for network security\n\n\nPage 37:\nModel for network security\n‚Ä¢ Using this model requires us to:\n‚Ä¢ design a suitable algorithm for the security transformation \n‚Ä¢ generate the secret information (keys) used by the algorithm \n‚Ä¢ develop methods to distribute and share the secret information \n‚Ä¢ specify a protocol enabling the principals to use the transformation and \nsecret information for a security service \n\n\nPage 38:\nSymmetric Encryption Principles\n\n\nPage 39:\nSymmetric encryption\n‚Ä¢ Sender and recipient share a common/same key\n‚Ä¢ Was the only type of cryptography, prior to invention of public-key in \n1970‚Äôs\n\n\nPage 40:\nSimplified model of symmetric encryption\n\n\nPage 41:\nSymmetric encryption\n‚Ä¢ Has five ingredients\n‚Ä¢ Plaintext:  the original message or data\n‚Ä¢ Encryption algorithm: performs various substitutions and transformations on \nthe plaintext\n‚Ä¢ Secret key\n‚Ä¢ Ciphertext: the coded message\n‚Ä¢ Decryption algorithm: takes the ciphertext and the same secret key and \nproduces the original plaintext\n\n\nPage 42:\nOther basic terminology\n‚Ä¢ cipher - algorithm for transforming plaintext to ciphertext \n‚Ä¢ encipher (encrypt) - converting plaintext to ciphertext\n‚Ä¢ decipher (decrypt) - recovering plaintext from ciphertext\n‚Ä¢ cryptography - study of encryption principles/methods\n‚Ä¢ cryptanalysis (",
    "chunk_order_index": 1,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-78a737c1d24ce9928bf7ecd37a5c886d": {
    "tokens": 1200,
    "content": "performs various substitutions and transformations on \nthe plaintext\n‚Ä¢ Secret key\n‚Ä¢ Ciphertext: the coded message\n‚Ä¢ Decryption algorithm: takes the ciphertext and the same secret key and \nproduces the original plaintext\n\n\nPage 42:\nOther basic terminology\n‚Ä¢ cipher - algorithm for transforming plaintext to ciphertext \n‚Ä¢ encipher (encrypt) - converting plaintext to ciphertext\n‚Ä¢ decipher (decrypt) - recovering plaintext from ciphertext\n‚Ä¢ cryptography - study of encryption principles/methods\n‚Ä¢ cryptanalysis (codebreaking) - the study of principles/ methods of \ndeciphering ciphertext without knowing key\n\n\nPage 43:\nRequirements\n‚Ä¢ Two requirements for secure use of symmetric encryption:\n‚Ä¢ a strong encryption algorithm\n‚Ä¢ a secret key known only to sender / receiver\nY = EK(X)\nX = DK(Y)\n‚Ä¢ assume encryption algorithm is known\n‚Ä¢ the security of symmetric encryption depends on the secrecy of the \nkey\n‚Ä¢ implies a secure channel to distribute key\n\n\nPage 44:\nA strong encryption algorithm\nattacker\nencryption algorithm\nplaintext / enquiry\ncyphertext / response\n\n\nPage 45:\nTA & Grader\n‚Ä¢ TA Name: Faiyaz, Amir (Project, Review & Quiz) \n‚Ä¢ Email:  afaiyaz@ttu.edu\n‚Ä¢ Reminder: Submit the names and emails of your group members to \nFALL 2024 CS5342 PROJECT GROUP NAMES.xlsx\n‚Ä¢ Grader Name: Han, Namgyu (Homework, Quiz, Exam grading)\n‚Ä¢ Email: Namgyu.Han@ttu.edu\n\n\nPage 46:\nA strong encryption algorithm\nattacker\nencryption algorithm\nplaintext / enquiry\ncyphertext / response\n\n\nPage 47:\nSecure Encryption Scheme\n‚Ä¢ Unconditional security\n‚Ä¢ no matter how much computer power is available, the cipher cannot be \nbroken since the ciphertext provides insufficient information to uniquely \ndetermine the corresponding plaintext\n‚Ä¢ Computational security\n‚Ä¢ the cost of breaking the cipher exceeds the value of the encrypted \ninformation;\n‚Ä¢ or the time required to break the cipher exceeds the useful lifetime of the \ninformation\n\n\nPage 48:\nDesired characteristics\n‚Ä¢ Cipher needs to completely obscure statistical properties of original \nmessage\n‚Ä¢ more practically Shannon suggested combining elements to obtain:\n‚Ä¢ Confusion ‚Äì how does changing a bit of the key affect the ciphertext?\n‚Ä¢ Diffusion ‚Äì how does changing one bit of the plaintext affect the ciphertext?\nconfusion\nciphertext\nplaintext\ndiffusion\n\n\nPage 49:\nWays to achieve\n‚Ä¢ Symmetric Encryption: \n‚Ä¢ substitution / transposition / hybrid\n‚Ä¢ Asymmetric Encryption: \n‚Ä¢ Mathematical hardness - problems that are efficient to compute in one \ndirection, but inefficient to reverse by the attacker\n‚Ä¢ Examples: Modular arithmetic, factoring, discrete logarithm problem, Elliptic Logs over \nElliptic Curves\n\n\nPage 50:\nTwo basic types\n‚Ä¢ Block Ciphers \n‚Ä¢ Typically 64, 128 bit blocks\n‚Ä¢ A k-bit plaintext block maps to a k-bit ciphertext block \n‚Ä¢ Usually employ Feistel structure \n‚Ä¢ Stream Ciphers\n‚Ä¢ A key is used to generate a stream of pseudo-random bits ‚Äì key stream\n‚Ä¢ Just XOR plaintext bits with the key stream for encryption \n‚Ä¢ For decryption generate the key stream and XOR with the ciphertext! \n\n\nPage 51:\nSymmetric Block Encryption\n\n\nPage 52:\nBlock cipher\n‚Ä¢ the most commonly used symmetric encryption algorithms\n‚Ä¢ input: fixed-size blocks (Typically 64, 128 bit blocks), output: equal \nsize blocks\n‚Ä¢ provide secrecy and/or authentication services\n‚Ä¢ Data Encryption Standard (DES), triple DES (3DES), and the Advanced \nEncryption Standard (AES)s\n‚Ä¢ Usually employ Feistel structure \n\n\nPage 53:\nFeistel Cipher Structure\n\n\nPage 54:\nFeistel Cipher Structure\n‚Ä¢ most symmetric block ciphers are based on a Feistel Cipher Structure\n‚Ä¢ based on the two primitive cryptographic operations\n‚Ä¢ substitution (S-box)\n‚Ä¢ permutation (P-box)\n‚Ä¢ provide confusion and diffusion of message \n\n\nPage 55:\nFeistel Cipher Structure\n‚Ä¢ Horst Feistel devised the feistel cipher in the 1973\n‚Ä¢ based on concept of invertible product cipher\n‚Ä¢ partitions input block into two halves\n‚Ä¢ process through multiple rounds which\n‚Ä¢ perform a substitution on left data half\n‚Ä¢ based on round function of right half & subkey\n‚Ä¢ then have permutation swapping halves\n‚Ä¢ implements Shannon‚Äôs substitution-permutation network concept\n\n\nPage 56:\nFeistel Encryption and Decryption \n\n\nPage 57:\nSymmetric Block Encryption\n\n\nPage 58:\nBlock cipher\n‚Ä¢ the most commonly used symmetric encryption algorithms\n‚Ä¢ input: fixed-size blocks (Typically 64, 128 bit blocks), output: equal \nsize blocks\n‚Ä¢ provide secrecy and/or authentication services\n‚Ä¢ Data Encryption Standard (DES), triple DES (3DES), and the Advanced \nEncryption Standard (AES)s\n‚Ä¢ Usually employ Feistel structure \n\n\nPage 59:\nFeistel Cipher Structure\n\n\nPage 60:\nFeistel Cipher Structure\n‚Ä¢ most symmetric block ciphers are based on a Feistel Cipher Structure\n‚Ä¢ based on the two primitive cryptographic operations\n‚Ä¢ substitution (S-box)\n‚Ä¢ permutation (P-box)\n‚Ä¢ provide confusion and diffusion of message \n\n\nPage 61:\nFeistel Cipher Structure\n‚Ä¢ Horst Feistel devised the feistel cipher in the 1973\n‚Ä¢ based on concept of invertible product cipher\n‚Ä¢ partitions input block into two halves\n‚Ä¢ process through multiple rounds which\n‚Ä¢ perform a substitution on left data half\n‚Ä¢ based on round function of right half & subkey\n‚Ä¢ then have permutation swapping halves\n‚Ä¢ implements Shannon‚Äôs substitution-permutation network concept\n\n\nPage 62:\nFeistel Encryption and Decryption \n\n\nPage 63:\n\n\nPage 64:\nFeistel Encryption and Decryption \n\n\nPage 65:\nDES encryption\n‚Ä¢\n64 bits plaintext\n‚Ä¢\n56 bits effective key length\n\n\nPage",
    "chunk_order_index": 2,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-6befc8b5cdb9c1cf26743c13e58a3dd0": {
    "tokens": 1200,
    "content": "‚Ä¢ partitions input block into two halves\n‚Ä¢ process through multiple rounds which\n‚Ä¢ perform a substitution on left data half\n‚Ä¢ based on round function of right half & subkey\n‚Ä¢ then have permutation swapping halves\n‚Ä¢ implements Shannon‚Äôs substitution-permutation network concept\n\n\nPage 62:\nFeistel Encryption and Decryption \n\n\nPage 63:\n\n\nPage 64:\nFeistel Encryption and Decryption \n\n\nPage 65:\nDES encryption\n‚Ä¢\n64 bits plaintext\n‚Ä¢\n56 bits effective key length\n\n\nPage 66:\nDES Weakness\n‚Ä¢ short length key (56 bits) is not secure enough. Brutal force search \ntakes short time. \n\n\nPage 67:\nTriple DES (3DES)\nDecrypting with the wrong key will further convolute the output\n\n\nPage 68:\n3DES\n‚Ä¢ Triple DES with three different keys ‚Äì brute-force complexity 2168\n‚Ä¢ 3DES is the FIPS-approved symmetric encryption algorithm\n‚Ä¢ Weakness: slow speed for encryption\nFIPS ‚Äì Federal Information Processing Standards. The United States' Federal Information Processing Standards are publicly announced \nstandards developed by the National Institute of Standards and Technology for use in computer systems by non-military American government \nagencies and government contractors\n\n\nPage 69:\nAES\n‚Ä¢ clearly a replacement for DES was needed\n‚Ä¢ have theoretical attacks that can break it\n‚Ä¢ have demonstrated exhaustive key search attacks\n‚Ä¢ can use Triple-DES ‚Äì but slow with small blocks\n‚Ä¢ US NIST issued call for ciphers in 1997\n‚Ä¢ 15 candidates accepted in Jun 98 \n‚Ä¢ 5 were short-listed in Aug-99 \n‚Ä¢ Rijndael was selected as the AES in Oct-2000\n‚Ä¢ issued as FIPS PUB 197 standard in Nov-2001 \n\n\nPage 70:\nCriteria to evaluate AES\n‚Ä¢ General security\n‚Ä¢ Software implementations\n‚Ä¢ Restricted-space environments\n‚Ä¢ Hardware implementations\n‚Ä¢ Attacks on implementations\n‚Ä¢ Encryption versus decryption\n‚Ä¢ Key agility\n‚Ä¢ Other versatility and flexibility\n‚Ä¢ Potential for instruction-level parallelism\nCryptographic Standards and Guidelines | CSRC (nist.gov)\n\n\nPage 71:\nAES Specification\n‚Ä¢ symmetric block cipher \n‚Ä¢ 128-bit data, 128/192/256-bit keys \n‚Ä¢ stronger & faster than Triple-DES \n‚Ä¢ provide full specification & design details \n‚Ä¢ both C & Java implementations\n‚Ä¢ NIST have released all submissions & unclassified analyses\nhttps://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-\nand-Guidelines/documents/aes-development/Rijndael-ammended.pdf\n\n\nPage 72:\nThe AES Cipher - Rijndael \n‚Ä¢ an iterative rather than feistel cipher\n‚Ä¢ treats data in 4 groups of 4 bytes\n‚Ä¢ operates an entire block in every round\n‚Ä¢ designed to be:\n‚Ä¢ resistant against known-plaintext attacks\n‚Ä¢ speed and code compactness on many CPUs\n‚Ä¢ design simplicity\n\n\nPage 73:\nRijndael\n‚Ä¢ processes data as 4 groups of 4 bytes (state) = 128 bits\n‚Ä¢ has 10/12/14 rounds in which state undergoes: \n‚Ä¢ byte substitution (1 S-box used on every byte) \n‚Ä¢ shift rows (permute bytes row by row) \n‚Ä¢ mix columns (alter each byte in a column as a function of all of the bytes in \nthe column) \n‚Ä¢ add round key (XOR state with key material) \n‚Ä¢ 128-bit keys ‚Äì 10 rounds, 192-bit keys ‚Äì 12 rounds, 256-bit keys ‚Äì 14 \nrounds\n\n\nPage 74:\nAES Specification\n‚Ä¢ symmetric block cipher \n‚Ä¢ 128-bit data, 128/192/256-bit keys \n‚Ä¢ stronger & faster than Triple-DES \n‚Ä¢ provide full specification & design details \n‚Ä¢ both C & Java implementations\n‚Ä¢ NIST have released all submissions & unclassified analyses\nhttps://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Standards-\nand-Guidelines/documents/aes-development/Rijndael-ammended.pdf\n\n\nPage 75:\nThe AES Cipher - Rijndael \n‚Ä¢ an iterative rather than feistel cipher\n‚Ä¢ treats data in 4 groups of 4 bytes\n‚Ä¢ operates an entire block in every round\n‚Ä¢ designed to be:\n‚Ä¢ resistant against known-plaintext attacks\n‚Ä¢ speed and code compactness on many CPUs\n‚Ä¢ design simplicity\n\n\nPage 76:\nRijndael\n‚Ä¢ processes data as 4 groups of 4 bytes (state) = 128 bits\n‚Ä¢ has 10/12/14 rounds in which state undergoes: \n‚Ä¢ byte substitution (1 S-box used on every byte) \n‚Ä¢ shift rows (permute bytes row by row) \n‚Ä¢ mix columns (alter each byte in a column as a function of all of the bytes in \nthe column) \n‚Ä¢ add round key (XOR state with key material) \n‚Ä¢ 128-bit keys ‚Äì 10 rounds, 192-bit keys ‚Äì 12 rounds, 256-bit keys ‚Äì 14 \nrounds\n\n\nPage 77:\nAES Encryption and Decryption\n\n\nPage 78:\nAES encryption round\n\n\nPage 79:\n\n\nPage 80:\nAES pros\n‚Ä¢ Most operations can be combined into XOR and table lookups - hence \nvery fast & efficient\n\n\nPage 81:\nTake-home Exercises\n‚Ä¢ Find an AES API to encrypt a text (A), then decrypt it and check \nwhether the original text (A) equals the decrypted text (B). Whether A \n= B?\n‚Ä¢ Compare the decryption time with different key lengths, and with DES \nand 3DES. \n‚Ä¢ Suggestions: find a large A file. Run decryption a couple of times and take the \naverage. \n\n\nPage 82:\nReading materials\n‚Ä¢ FIPS 197, Advanced Encryption Standard (AES) (nist.gov)\n\n\nPage 83",
    "chunk_order_index": 3,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-857f19665925777874ea4ce8165de2d4": {
    "tokens": 1200,
    "content": "text (A), then decrypt it and check \nwhether the original text (A) equals the decrypted text (B). Whether A \n= B?\n‚Ä¢ Compare the decryption time with different key lengths, and with DES \nand 3DES. \n‚Ä¢ Suggestions: find a large A file. Run decryption a couple of times and take the \naverage. \n\n\nPage 82:\nReading materials\n‚Ä¢ FIPS 197, Advanced Encryption Standard (AES) (nist.gov)\n\n\nPage 83:\nWPEC 2024: NIST Workshop on Privacy-\nEnhancing Cryptography\n‚Ä¢ Time: September 24‚Äì26, 2024\n‚Ä¢ Free to register\n‚Ä¢ Virtual conference via Zoom\n‚Ä¢ https://csrc.nist.gov/events/2024/wpec2024\n\n\nPage 84:\nRandom and Pseudorandom Numbers\n\n\nPage 85:\nWhen to use random numbers?\n‚Ä¢ Generation of a stream key for symmetric stream cipher \n‚Ä¢ Generation of keys for public-key algorithms\n‚Ä¢ RSA public-key encryption algorithm (described in Chapter 3)\n‚Ä¢ Generation of a symmetric key for use as a temporary session key\n‚Ä¢ used in a number of networking applications, such as Transport Layer Security \n(Chapter 5), Wi-Fi (Chapter 6), e-mail security (Chapter 7), and IP security \n(Chapter 8) \n‚Ä¢ In a number of key distribution scenarios\n‚Ä¢ Kerberos (Chapter 4)\n\n\nPage 86:\nTwo types of random numbers\n‚Ä¢ True random numbers:\n‚Ä¢ generated in non-deterministic ways. They are not predictable and repeatable\n‚Ä¢ Pseudorandom numbers:\n‚Ä¢ appear random, but are obtained in a deterministic, repeatable, and \npredictable manner\n\n\nPage 87:\nProperties of Random Numbers\n‚Ä¢ Randomness\n‚Ä¢ Uniformity\n‚Ä¢ distribution of bits in the sequence should be uniform \n‚Ä¢ Independence\n‚Ä¢ no one subsequence in the sequence can be inferred from the others \n‚Ä¢ Unpredictable\n‚Ä¢ satisfies the \"next-bit test‚Äú\n\n\nPage 88:\nEntropy\n‚Ä¢ A measure of uncertainty\n‚Ä¢ In other words, a measure of how unpredictable the outcomes are\n‚Ä¢ High entropy = unpredictable outcomes = desirable in cryptography\n‚Ä¢ The uniform distribution has the highest entropy (every outcome equally \nlikely, e.g. fair coin toss)\n‚Ä¢ Usually measured in bits (so 3 bits of entropy = uniform, random distribution \nover 8 values)\nEntropy of an information source\n\n\nPage 89:\n\n\nPage 90:\nProperties of Random Numbers\n‚Ä¢ Randomness\n‚Ä¢ Uniformity\n‚Ä¢ distribution of bits in the sequence should be uniform \n‚Ä¢ Independence\n‚Ä¢ no one subsequence in the sequence can be inferred from the others \n‚Ä¢ Unpredictable\n‚Ä¢ satisfies the \"next-bit test‚Äú\n\n\nPage 91:\nEntropy\n‚Ä¢ A measure of uncertainty\n‚Ä¢ In other words, a measure of how unpredictable the outcomes are\n‚Ä¢ High entropy = unpredictable outcomes = desirable in cryptography\n‚Ä¢ The uniform distribution has the highest entropy (every outcome equally \nlikely, e.g. fair coin toss)\n‚Ä¢ Usually measured in bits (so 3 bits of entropy = uniform, random distribution \nover 8 values)\nEntropy of an information source\n\n\nPage 92:\n\n\nPage 93:\n\n\nPage 94:\nTrue random numbers generators\n‚Ä¢ Several sources of randomness ‚Äì natural sources of randomness\n‚Ä¢ decay times of radioactive materials\n‚Ä¢ electrical noise from a resistor or semiconductor\n‚Ä¢ radio channel or audible noise\n‚Ä¢ keyboard timings\n‚Ä¢ disk electrical activity\n‚Ä¢ mouse movements\n‚Ä¢ Physical unclonable function (PUF)\n‚Ä¢ Some are better than others\n\n\nPage 95:\nCombining sources of randomness\n‚Ä¢ Suppose r1, r2, ‚Ä¶, rk are random numbers from different sources. \nE.g.,\nr1 = electrical noise from a resistor or semiconductor\nr2 = sample of hip-hop music on radio\nr3 = clock on computer\nb = r1‚äïr2‚äï‚Ä¶‚äïrk\nIf any one of r1, r2, ‚Ä¶, rk is truly random, then so is b\nMany poor sources + 1 good source = good entropy\n\n\nPage 96:\nPseudorandom Number Generators (PRNGs)\n‚Ä¢ True randomness is expensive\n‚Ä¢ Pseudorandom number generator (PRNGs): An algorithm that uses a \nlittle bit of true randomness to generate a lot of random-looking \noutput\n‚Ä¢ Also called deterministic random bit generators (DRBGs)\n‚Ä¢ PRNGs are deterministic: Output is generated according to a set \nalgorithm\n‚Ä¢ However, for an attacker who can‚Äôt see the internal state, the output is \ncomputationally indistinguishable from true randomness\n\n\nPage 97:\nPseudorandom Number Generators (PRNGs)\n‚Ä¢ True randomness is expensive\n‚Ä¢ Pseudorandom number generator (PRNGs): An algorithm that uses a \nlittle bit of true randomness to generate a lot of random-looking \noutput\n‚Ä¢ Also called deterministic random bit generators (DRBGs)\n‚Ä¢ PRNGs are deterministic: Output is generated according to a set \nalgorithm\n‚Ä¢ However, for an attacker who can‚Äôt see the internal state, the output is \ncomputationally indistinguishable from true randomness\n\n\nPage 98:\nPRNG: Definition\n‚Ä¢ A PRNG has two functions:\n‚Ä¢ PRNG.Seed(randomness): Initializes the internal state using the entropy\n‚Ä¢ Input: Some truly random bits\n‚Ä¢ PRNG.Generate(n): Generate n pseudorandom bits\n‚Ä¢ Input: A number n\n‚Ä¢ Output: n pseudorandom bits\n‚Ä¢ Updates the internal state as needed\n‚Ä¢ Properties\n‚Ä¢ Correctness: Deterministic\n‚Ä¢ Efficiency: Efficient to generate pseudorandom bits\n‚Ä¢ Security: Indistinguishability from random\n‚Ä¢ Rollback resistance: cannot deduce anything about any previously-generated bit\n\n\nPage 99:\nExample construction of",
    "chunk_order_index": 4,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-6506e5e6caf49ce92f0eb67efad106b4": {
    "tokens": 1200,
    "content": "‚Ä¢ Input: Some truly random bits\n‚Ä¢ PRNG.Generate(n): Generate n pseudorandom bits\n‚Ä¢ Input: A number n\n‚Ä¢ Output: n pseudorandom bits\n‚Ä¢ Updates the internal state as needed\n‚Ä¢ Properties\n‚Ä¢ Correctness: Deterministic\n‚Ä¢ Efficiency: Efficient to generate pseudorandom bits\n‚Ä¢ Security: Indistinguishability from random\n‚Ä¢ Rollback resistance: cannot deduce anything about any previously-generated bit\n\n\nPage 99:\nExample construction of PRNG\n‚Ä¢ Using block cipher in Counter (CTR) mode:\n‚Ä¢ If you want m random bits, and a block cipher with Ek has n bits, apply the \nblock cipher m/n times and concatenate the result:\n‚Ä¢ PRNG.Seed(K | IV) = Ek(IV, 1) | Ek(IV, 2) | Ek(IV, 3) ‚Ä¶ Ek(IV, ceil(m/n)),\n‚Ä¢ | is concatenation\n‚Ä¢ Initialization vector (IV) / Nonce ‚Äì typically is random or pseudorandom\nRandomness, \nPRNG output\n\n\nPage 100:\nPRNG: Security\n‚Ä¢ Can we design a PRNG that is truly random?\n‚Ä¢ A PRNG cannot be truly random\n‚Ä¢ The output is deterministic given the initial seed\n‚Ä¢ A secure PRNG is computationally indistinguishable from random to \nan attacker\n‚Ä¢ Game: Present an attacker with a truly random sequence and a sequence \noutputted from a secure PRNG\n‚Ä¢ An attacker should be able to determine which is which with probability ‚âà0\n‚Ä¢ Equivalence: An attacker cannot predict future output of the PRNG\n\n\nPage 101:\nCreate pseudorandom numbers\n‚Ä¢ Truly random numbers are impossible with any program!\n‚Ä¢ However, we can generate seemingly random numbers, called \npseudorandom numbers\n‚Ä¢ The function rand() returns a non-negative number between 0 and \nRAND_MAX\n‚Ä¢ For C, it is defined in stdlib.h\n‚Ä¢ arc4random() is a function available in some operating systems (primarily \nBSD-based systems like macOS and FreeBSD) that generates random \nnumbers. It is part of the C standard library and provides a more secure \nand higher-quality source of random numbers compared to rand()\n\n\nPage 102:\nPRNGs: Summary\n‚Ä¢ True randomness requires sampling a physical process\n‚Ä¢ PRNG: An algorithm that uses a little bit of true randomness to \ngenerate a lot of random-looking output\n‚Ä¢ Seed(entropy): Initialize internal state\n‚Ä¢ Generate(n): Generate n bits of pseudorandom output\n‚Ä¢ Security: computationally indistinguishable from truly random bits\n\n\nPage 103:\nStream Ciphers\n\n\nPage 104:\nStream Ciphers\n‚Ä¢ process the message bit by bit (as a stream) \n‚Ä¢ typically have a (pseudo) random stream key\n‚Ä¢ combined (XOR) with plaintext bit by bit \n‚Ä¢ randomness of stream key completely destroys any statistically \nproperties in the message \n‚Ä¢ Ci = Mi XOR StreamKeyi\n‚Ä¢ what could be simpler!!!! \n‚Ä¢ but must never reuse stream key\n‚Ä¢ otherwise, can remove effect and recover messages, M‚®ÅK‚®ÅK = M\n\n\nPage 105:\nStream Ciphers\n‚Ä¢ process the message bit by bit (as a stream) \n‚Ä¢ typically have a (pseudo) random stream key\n‚Ä¢ combined (XOR) with plaintext bit by bit \n‚Ä¢ randomness of stream key completely destroys any statistically \nproperties in the message \n‚Ä¢ Ci = Mi XOR StreamKeyi\n‚Ä¢ what could be simpler!!!! \n‚Ä¢ but must never reuse stream key\n‚Ä¢ otherwise, can remove effect and recover messages, M‚®ÅK‚®ÅK = M\n\n\nPage 106:\nStream Cipher Properties\n‚Ä¢ some design considerations are:\n‚Ä¢ statistically random \n‚Ä¢ depends on large enough key\n‚Ä¢ large linear complexity\n‚Ä¢ correlation immunity \n‚Ä¢ confusion\n‚Ä¢ diffusion\n\n\nPage 107:\nHow to generate Stream Key?\n‚Ä¢ How to generate Stream Key?\n\n\nPage 108:\nStream Ciphers \n‚Ä¢ Idea: replace ‚Äúrand‚Äù by ‚Äúpseudo rand‚Äù\n‚Ä¢ Use Pseudo Random Number Generator \n‚Ä¢ A secure PRNG produces output that looks indistinguishable from random\n‚Ä¢ An attacker who can‚Äôt see the internal PRNG state can‚Äôt learn any output\n‚Ä¢ PRNG: {0,1}s ¬Æ {0,1}n\n‚Ä¢ expand a short (e.g., 128-bit) random seed into a long (typically unbounded) \nstring that ‚Äúlooks random‚Äù\n‚Ä¢ Secret key is the seed\n‚Ä¢ Basic encryption method: Ekey[M] = M √Ö PRNG(key)\n\n\nPage 109:\nStream Ciphers\n‚Ä¢ Protocol: Alice and Bob both seed a secure PRNG with their \nsymmetric secret key, and then use the output as the key for stream \nkey\nAlice\nBob\nSeed(k)\nSeed(k)\nGenerate(n)\nGenerate(n)\nPlaintext\nPlaintext\nCiphertext\n‚äï\n‚äï\n\n\nPage 110:\nStream Ciphers: Encrypting Multiple Messages\n‚Ä¢ How do we encrypt multiple messages without key reuses?\nAlice\nBob\nSeed(k)\nSeed(k)\nGenerate(n)\nGenerate(n)\nPlaintext\nPlaintext\nCiphertext\n‚äï\n‚äï\n\n\nPage 111:\nStream Ciphers: Encrypting Multiple Messages\n‚Ä¢ Solution: For each message, seed the PRNG with the key and a \nrandom IV, concatenated(‚Äú|‚Äù). Send the IV with the ciphertext\nAlice\nBob\nSeed(k | IV)\nSeed(k | IV)\nGenerate(n)\nGenerate(n)\nPlaintext\nPlaintext\nCiphertext\n‚äï\n‚äï\nIV\nIV\n\n\nPage 112:\nReal-world example: RC4\n‚Ä¢ a proprietary cipher designed in 1987 \n‚Ä¢ Extremely simple but effective!\n‚Ä¢ Very fast - especially in software\n‚Ä¢ Easily adapts to any key length, byte-oriented",
    "chunk_order_index": 5,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-bfecccc5e9fe10287ed4f436521ec522": {
    "tokens": 1200,
    "content": "IV, concatenated(‚Äú|‚Äù). Send the IV with the ciphertext\nAlice\nBob\nSeed(k | IV)\nSeed(k | IV)\nGenerate(n)\nGenerate(n)\nPlaintext\nPlaintext\nCiphertext\n‚äï\n‚äï\nIV\nIV\n\n\nPage 112:\nReal-world example: RC4\n‚Ä¢ a proprietary cipher designed in 1987 \n‚Ä¢ Extremely simple but effective!\n‚Ä¢ Very fast - especially in software\n‚Ä¢ Easily adapts to any key length, byte-oriented stream cipher \n‚Ä¢ widely used (web SSL/TLS, wireless WEP, WAP) \n‚Ä¢ A trade secret by RSA Security\n‚Ä¢ uses that permutation to scramble input info processed a byte at a \ntime \n\n\nPage 113:\nRC4 Stream Cipher\nK\nRC4 (K|IV)\n011010010111\n‚äï\nM\nC\nkey\n(seed)\nkey stream\n(pseudo random sequence)\nmessage\nciphertext\n\n\nPage 114:\nRC4 Key Schedule\n‚Ä¢ starts with an array S of \nnumbers: 0‚Ä¶255\n‚Ä¢ use key to well and truly \nshuffle\n‚Ä¢ S forms internal state of \nthe cipher\n‚Ä¢ given a key k of length I \nbytes\nThrow away T & K, retain S\n\n\nPage 115:\n\n\nPage 116:\nRC4 Stream Cipher\nK\nRC4 (K|IV)\n011010010111\n‚äï\nM\nC\nkey\n(seed)\nkey stream\n(pseudo random sequence)\nmessage\nciphertext\n\n\nPage 117:\nRC4 Key Schedule\n‚Ä¢ starts with an array S of \nnumbers: 0‚Ä¶255\n‚Ä¢ use key to well and truly \nshuffle\n‚Ä¢ S forms internal state of \nthe cipher\n‚Ä¢ given a key k of length I \nbytes\nThrow away T & K, retain S\n\n\nPage 118:\n\n\nPage 119:\nRC4 Encryption\n‚Ä¢ encryption continues \nshuffling array values\n‚Ä¢ sum of shuffled pair \nselects \"stream key\" \nvalue\n‚Ä¢ XOR with next byte of \nmessage to en/decrypt\n\n\nPage 120:\nRC4\n\n\nPage 121:\nRC4 Security\n‚Ä¢ claimed secure against known attacks\n‚Ä¢ since RC4 is a stream cipher, must never reuse a key\n‚Ä¢ have a concern with WEP, but due to key handling rather than RC4 \nitself \n‚Ä¢ RC4 Biases: It is extensively studied, not a completely secure PRNG, \nfirst part of output biased, when used as stream cipher, should use \nRC4-Drop[n]\n‚Ä¢ Which drops first n bytes before using the output\n‚Ä¢ Conservatively, set n=3072\n\n\nPage 122:\nSummary ‚Äì Chapter 2\n‚Ä¢ Symmetric block cipher\n‚Ä¢ DES, 3DES\n‚Ä¢ AES\n‚Ä¢ Random number\n‚Ä¢ true random number\n‚Ä¢ pseudorandom number\n‚Ä¢ Stream cipher \n‚Ä¢ The security of symmetric encryption depends on the secrecy of the \nkey\n‚Ä¢ Symmetric encryption: pros and cons \n\n\nPage 123:\nModular Arithmetic\n‚Ä¢ Definition (congruent modulo): \n‚Ä¢ given b ‚Äì a = km for some k ùúñùëç, then a ‚â°ùëè(mod m)\n‚Ä¢ Given a ‚â°ùëè(mod m) and c ‚â°ùëë(mod m), then\n‚Ä¢ a + b ‚â°c + d (mod m)\n‚Ä¢ a - b ‚â°c - d (mod m)\n‚Ä¢ a + c ‚â°b + d (mod m)\n‚Ä¢ a √ó c ‚â°b √ó d (mod m)\n‚Ä¢ ak ‚â°bk (mod m)\n‚Ä¢ ka = kb (mod m)\n‚Ä¢ p(a) ‚â°p(b) (mod m), any polynomial p(x) with integer coefficients\n‚Ä¢ A ‚®Åùêµ‚®Åùêµ= A\n\n\nPage 124:\nThank you!\n\n\nPage 125:\nNetwork Security\nChapter 3\nPublic-Key Cryptography and Message Authentication\n\n\nPage 126:\nPublic-Key Cryptography\n\n\nPage 127:\nConventional cryptography\n‚Ä¢ traditional private/secret/single-key cryptography uses one key \n‚Ä¢ shared by both sender and receiver \n‚Ä¢ if this key is disclosed, communications are compromised \n‚Ä¢ also is symmetric, parties are equal \n\n\nPage 128:\nPros and cons\n‚Ä¢ Pros:\n‚Ä¢ Encryption is fast for large amounts of data\n‚Ä¢ Provide the same level of security with a shorter encryption key\n‚Ä¢ By now, it‚Äôs unbreakable to quantum computing\n‚Ä¢ Cons\n‚Ä¢ Key distribution assumes a secure channel\n‚Ä¢ Does not protect sender from receiver forging a message & claiming it‚Äôs sent \nby sender\n‚Ä¢ It does not scale well for large networks. It requires a separate key for each \npair of communicating parties, which can result in a large number of keys to \nmanage and protect. \n\n\nPage 129:\nHomework 1 - individual\n‚Ä¢ Chapter 1 & 2\n‚Ä¢ Deadline: Tuesday, October 8, 11:59 PM\n‚Ä¢ Submit your homework via the provided link.\n‚Ä¢ The Google submission timestamp will be considered final.\n‚Ä¢ A 10% penalty will be applied for each day of late submission.\n\n\nPage 130:\nReview & Quiz I\n‚Ä¢ Chapter 1 & 2\n‚Ä¢ Wednesday (Oct. 9, 2024), in class\n‚Ä¢ Please ensure your participation\n‚Ä¢ No make-up quiz\n\n\nPage 131:\nPublic-Key Cryptography\n‚Ä¢ In public-key schemes, each person has two keys\n‚Ä¢ Public key: Known to everybody\n‚Ä¢ Private key: Only known by that person\n‚Ä¢ Keys come in pairs: every public key corresponds to one private key\n‚Ä¢ Uses number theory\n‚Ä¢ Examples: Modular arithmetic, factoring, discrete logarithm problem, \nElliptic logs over Elliptic Curves\n‚Ä¢ Contrast with symmetric-key cryptography (uses XORs and bit-shifts)\n‚Ä¢ Messages are numbers",
    "chunk_order_index": 6,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-c33e98766f727bb94472b30f064d74d1": {
    "tokens": 1200,
    "content": "-Key Cryptography\n‚Ä¢ In public-key schemes, each person has two keys\n‚Ä¢ Public key: Known to everybody\n‚Ä¢ Private key: Only known by that person\n‚Ä¢ Keys come in pairs: every public key corresponds to one private key\n‚Ä¢ Uses number theory\n‚Ä¢ Examples: Modular arithmetic, factoring, discrete logarithm problem, \nElliptic logs over Elliptic Curves\n‚Ä¢ Contrast with symmetric-key cryptography (uses XORs and bit-shifts)\n‚Ä¢ Messages are numbers\n‚Ä¢ Contrast with symmetric-key cryptography (messages are bit strings)\n\n\nPage 132:\nPublic-key Cryptography\n‚Ä¢ Benefit:\n‚Ä¢ Drawback:\n‚Ä¢ Benefit: No longer need to assume that Alice and Bob already share a \nsecret\n‚Ä¢ Drawback: Much slower than symmetric-key cryptography\n‚Ä¢ Number theory calculations are much slower than XORs and bit-shifts\n\n\nPage 133:\nReading materials\n‚Ä¢ Encryption: Strengths and Weaknesses of Public-key Cryptography\n‚Ä¢ Public-key cryptography is a public invention due to Whitfield Diffie & \nMartin Hellman at Stanford Uni in 1976\n\n\nPage 134:\nPublic-key cryptography\n‚Ä¢ public-key/two-key/asymmetric cryptography involves the use of \ntwo keys: \n‚Ä¢ a public-key, which may be known by anybody, and can be used to encrypt \nmessages, and verify signatures\n‚Ä¢ a private-key, known only to the recipient, used to decrypt messages, and \nsign (create) signatures\n‚Ä¢ is asymmetric because\n‚Ä¢ Not the same key\n‚Ä¢ those who encrypt messages or verify signatures cannot decrypt messages or \ncreate signatures\n\n\nPage 135:\nPublic-Key Encryption\n‚Ä¢ Everybody can encrypt with the public key\n‚Ä¢ Only the recipient can decrypt with the private key\n\n\nPage 136:\nPublic-Key Cryptography - Encryption\n\n\nPage 137:\nEncryption steps\n‚Ä¢ step1: generate a pair of keys\n‚Ä¢ step2: keep the private key / secret key (SK) and distribute the public \nkey (PK) ‚Äì place PK in a public register or other accessible file\n‚Ä¢ step3: Bob encrypts the message with Alice‚Äôs PK\n‚Ä¢ step4: upon receiving the ciphertext (CT), Alice decrypt CT with SK\n\n\nPage 138:\nAn example of key distribution\nSSH key-based client authentication. Source: Peiyue and \nYuanyuan 2021.\n1.Peiyue, G. and F. Yuanyuan. 2021. \"What Is SSH?\" Info-Finder, Huawei, July \n22. Updated 2021-12-14. Accessed 2023-04-18.\n\n\nPage 139:\nEncryption steps\n‚Ä¢ step1: generate a pair of keys\n‚Ä¢ step2: keep the private key / secret key (SK) and distribute the public \nkey (PK) ‚Äì place PK in a public register or other accessible file\n‚Ä¢ step3: Bob encrypts the message with Alice‚Äôs PK\n‚Ä¢ step4: upon receiving the ciphertext (CT), Alice decrypt CT with SK\n\n\nPage 140:\nPublic-Key Encryption: Definition\n‚Ä¢ Three parts:\n‚Ä¢ KeyGen() ‚Üí PK, SK: Generate a public/private keypair, where PK is the public \nkey, and SK is the private (secret) key\n‚Ä¢ Enc(PK, M) ‚Üí C: Encrypt a plaintext M using public key PK to produce \nciphertext C\n‚Ä¢ Dec(SK, C) ‚Üí M: Decrypt a ciphertext C using secret key SK\n‚Ä¢ Properties\n‚Ä¢ Correctness: Decrypting a ciphertext should result in the message that was \noriginally encrypted\n‚Ä¢ Dec(SK, Enc(PK, M)) = M for all PK, SK ‚Üê KeyGen() and M\n‚Ä¢ Efficiency: Encryption/decryption should be fast\n‚Ä¢ Security: 1. Alice (the challenger) just gives Eve (the adversary) the public key, \nand Eve doesn‚Äôt request encryptions. Eve cannot guess out anything; 2. \ncomputationally infeasible to recover M with PK and ciphertext\n\n\nPage 141:\nPublic-Key Cryptography - Signature\n\n\nPage 142:\nReview\nPrivate Key\nPublic Key\nSignature\nEncryption\n\n\nPage 143:\nPublic-Key application\n‚Ä¢ can classify uses into 3 categories:\n‚Ä¢ encryption/decryption (provide secrecy)\n‚Ä¢ digital signatures (provide authentication)\n‚Ä¢ key exchange (of session keys)\n‚Ä¢ some algorithms are suitable for all uses; others are specific to one\n‚Ä¢ Either of the two related keys can be used for encryption, with the \nother used for decryption\n\n\nPage 144:\nSecurity of Public Key Schemes\n‚Ä¢ Keys used are very large (>512bits) \n‚Ä¢ like private key schemes brute force exhaustive search attack is always \ntheoretically possible \n‚Ä¢ Security relies on a large enough difference in difficulty between easy \n(en/decrypt) and hard (cryptanalyze) problems\n‚Ä¢ more generally the hard problem is known, it‚Äôs just made too hard to do in \npractice \n‚Ä¢ Requires the use of very large numbers, hence is slow compared to \nprivate/symmetric key schemes\n\n\nPage 145:\nPublic-Key Cryptography Algorithm\n(RSA)\n\n\nPage 146:\nRSA Public-key encryption\n‚Ä¢ by Rivest, Shamir & Adleman of MIT in 1977 \n‚Ä¢ currently the ‚Äúwork horse‚Äù of Internet security\n‚Ä¢ most public key infrastructure (PKI) products\n‚Ä¢ SSL/TLS: certificates and key-exchange\n‚Ä¢ secure e-mail: PGP, Outlook, ‚Ä¶.\n‚Ä¢ based on exponentiation in a finite (Galois) field over integers modulo a \nprime \n‚Ä¢ exponentiation takes O((log n)3) operations (easy)\n‚Ä¢ security due to cost of factoring large integer numbers \n‚Ä¢ factorization takes O(e log n log log n) operations (hard)\n‚Ä¢ uses large integers (eg. 1024 bits)\n\n\nPage 147:\nRSA key setup",
    "chunk_order_index": 7,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-4e4a904bf47f1b6c3528497783ff36c0": {
    "tokens": 1200,
    "content": "and key-exchange\n‚Ä¢ secure e-mail: PGP, Outlook, ‚Ä¶.\n‚Ä¢ based on exponentiation in a finite (Galois) field over integers modulo a \nprime \n‚Ä¢ exponentiation takes O((log n)3) operations (easy)\n‚Ä¢ security due to cost of factoring large integer numbers \n‚Ä¢ factorization takes O(e log n log log n) operations (hard)\n‚Ä¢ uses large integers (eg. 1024 bits)\n\n\nPage 147:\nRSA key setup\n‚Ä¢ each user generates a public/private key pair by: \n‚Ä¢ selecting two large primes at random - p, q\n‚Ä¢ computing their system modulus n=p!q\n‚Ä¢ note √∏(n)=(p-1)(q-1)\n‚Ä¢ selecting at random the encryption key e\n‚Ä¢ where 1<e<√∏(n), gcd(e,√∏(n))=1 \n‚Ä¢ solve following equation to find decryption key d\n‚Ä¢ ed=1 mod √∏(n)\n‚Ä¢ publish their public encryption key: pk={e,n} \n‚Ä¢ keep secret private decryption key: sk={d,p,q} \n\n\nPage 148:\n\n\nPage 149:\nRSA example\n1.\nSelect primes: p=17 & q=11\n2.\nCompute n = pq =17√ó11=187\n3.\nCompute √∏(n)=(p‚Äì1)(q-1)=16√ó10=160\n4.\nSelect e : gcd(e,160)=1; choose e=7\n5.\nDetermine d: de=1 mod 160 and d < 160 Value is d=23 since \n23√ó7=161= 10√ó160+1\n6.\nPublish public key pk={7,187}\n7.\nKeep secret private key sk={23,17,11}\n\n\nPage 150:\nRSA example\n1.\nSelect primes: p=17 & q=11\n2.\nCompute n = pq =17√ó11=187\n3.\nCompute √∏(n)=(p‚Äì1)(q-1)=16√ó10=160\n4.\nSelect e : gcd(e,160)=1; choose e=7\n5.\nDetermine d: de=1 mod 160 and d < 160 Value is d=23 since \n23√ó7=161= 10√ó160+1\n6.\nPublish public key pk={7,187}\n7.\nKeep secret private key sk={23,17,11}\n\n\nPage 151:\nRSA use\n‚Ä¢ to encrypt a message M the sender:\n‚Ä¢ obtains public key of recipient pk={e,n}\n‚Ä¢ computes: C=Me mod n, where 0‚â§M<n\n‚Ä¢ to decrypt the ciphertext C the owner:\n‚Ä¢ uses their private key sk={d,p,q}\n‚Ä¢ computes: M=Cd mod n\n‚Ä¢ note that the message M must be smaller than the modulus n (block \nif needed)\nPlaintext\nCiphertext\nC = ùëÄ!\npk={e,n}\nsk={d,p,q}\n\n\nPage 152:\nRSA example continue\n‚Ä¢ sample RSA encryption/decryption is: \n‚Ä¢ given message M = 88 ( 88<187)\n‚Ä¢ encryption:\nC = 887 mod 187 = 11\n‚Ä¢ decryption:\nM = 1123 mod 187 = 88\n\n\nPage 153:\nExample of RSA algorithm\n\n\nPage 154:\nRSA key generation\n‚Ä¢ users of RSA must:\n‚Ä¢ determine two primes at random - p, q\n‚Ä¢ select either e or d and compute the other\n‚Ä¢ primes p,q must not be easily derived from modulus n=p.q\n‚Ä¢ means must be sufficiently large\n‚Ä¢ typically guess and use probabilistic test\n‚Ä¢ exponents e, d are inverses, so use Inverse algorithm to compute the \nother\n\n\nPage 155:\nCorrectness of RSA\n‚Ä¢ Euler‚Äôs theorem: if gcd (M, n) = 1, then ùëÄ!(#) = 1 mod n. Here œÜ(n) \nis Euler‚Äôs totient function: the number of integers in {1, 2, . . ., n-1} \nwhich are relatively prime to n. When n is a prime, this theorem is \njust Fermat‚Äôs little theorem\nM‚Äô = ùê∂% mod n = ùëÄ&% mod n\n=  ùëÄ(! # )* mod n\n=  [ùëÄ!(#)](, ùëÄ mod n\n= M  mod n\n\n\nPage 156:\n\n\nPage 157:\nAttack approaches\n‚Ä¢ Mathematical attacks: several approaches, all equivalent in effort to \nfactoring the product of two primes. The defense against \nmathematical attacks is to use a large key size. \n‚Ä¢ Timing attacks: These depend on the running time of the decryption \nalgorithm\n‚Ä¢ Chosen ciphertext attacks: this type of attacks exploits properties of \nthe RSA algorithm by selecting blocks of data. These attacks can be \nthwarted by suitable padding of the plaintext, such as PKCS1 V1.5 in \nSSL\n\n\nPage 158:\nA simple attack on textbook RSA\n‚Ä¢ Session-key  K is 64 bits.     View   K √é {0,‚Ä¶,264}\n‚Ä¢ Eavesdropper sees:    C = Ke (mod N) .\n‚Ä¢ Suppose   K = K1√óK2 where   K1, K2 < 234 .   \n‚Ä¢ Then:    C/K1\ne = K2\ne (mod N)\n‚Ä¢ Build table:   C/1e, C/2e, C/3e, ‚Ä¶, C/234e .   time:  234\nFor  K2 = 0,‚Ä¶, 234 test if  K2\ne is in table.   time: 234√ó34\n‚Ä¢ Attack time:   ¬ª240  << 264\nWeb \nBrowser\nWeb",
    "chunk_order_index": 8,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-b06aeee6d2eaab42ebb3c8ec791a308c": {
    "tokens": 1200,
    "content": "‚Ä¢ Then:    C/K1\ne = K2\ne (mod N)\n‚Ä¢ Build table:   C/1e, C/2e, C/3e, ‚Ä¶, C/234e .   time:  234\nFor  K2 = 0,‚Ä¶, 234 test if  K2\ne is in table.   time: 234√ó34\n‚Ä¢ Attack time:   ¬ª240  << 264\nWeb \nBrowser\nWeb\nServer\nRandom session key K\nd\nClient Hello\nServer Hello (e, N)\nC = RSA (K)\n\n\nPage 159:\nAttack approaches\n‚Ä¢ Mathematical attacks: several approaches, all equivalent in effort to \nfactoring the product of two primes. The defense against \nmathematical attacks is to use a large key size. \n‚Ä¢ Timing attacks: These depend on the running time of the decryption \nalgorithm\n‚Ä¢ Chosen ciphertext attacks: this type of attacks exploits properties of \nthe RSA algorithm by selecting blocks of data. These attacks can be \nthwarted by suitable padding of the plaintext, such as PKCS1 V1.5 in \nSSL\n\n\nPage 160:\nA simple attack on textbook RSA\n‚Ä¢ Session-key  K is 64 bits.     View   K √é {0,‚Ä¶,264}\n‚Ä¢ Eavesdropper sees:    C = Ke (mod N) .\n‚Ä¢ Suppose   K = K1√óK2 where   K1, K2 < 234 .   \n‚Ä¢ Then:    C/K1\ne = K2\ne (mod N)\n‚Ä¢ Build table:   C/1e, C/2e, C/3e, ‚Ä¶, C/234e .   time:  234\nFor  K2 = 0,‚Ä¶, 234 test if  K2\ne is in table.   time: 234√ó34\n‚Ä¢ Attack time:   ¬ª240  << 264\nWeb \nBrowser\nWeb\nServer\nRandom session key K\nd\nClient Hello\nServer Hello (e, N)\nC = RSA (K)\n\n\nPage 161:\nTake-home exercise ‚Äì no need to submit \n‚Ä¢ SW textbook (6th edition) problems: 3.14 & 3.15\n\n\nPage 162:\nHomomorphic encryption \n‚Ä¢ Encryption scheme that allows computation on ciphertexts \n‚Ä¢ an extension of public-key encryption scheme that allows anyone in \npossession of the public key to perform operations on encrypted data without \naccess to the decryption key\n‚Ä¢ Partially Homomorphic Encryption: Initial public-key systems that \nallow this for either addition or multiplication, but not both.\n‚Ä¢ i.e. RSA\n‚Ä¢ Fully homomorphic encryption (FHE)\n\n\nPage 163:\nApplication of homomorphic encryption \n‚Ä¢ One Use case: cloud computing \n‚Ä¢ A weak computational device Alice (e.g., a mobile phone or a laptop) wishes \nto perform a computationally heavy task, beyond her computational means. \nShe can delegate it to a much stronger (but still feasible) machine Bob (the \ncloud, or a supercomputer) who offers the service of doing so. The problem is \nthat Alice does not trust Bob, who may give the wrong answer due to laziness, \nfault, or malice.\nE (Pk, data)\nE (Pk, f(data))\n\n\nPage 164:\nRSA reading materials\n‚Ä¢ A Method for Obtaining Digital Signatures and Public-Key \nCryptosystems\n\n\nPage 165:\nMessage Authentication\n\n\nPage 166:\nMessage authentication\n‚Ä¢ message authentication is concerned with: \n‚Ä¢ protecting the integrity of a message \n‚Ä¢ validating identity of originator \n‚Ä¢ non-repudiation of origin (dispute resolution)\n‚Ä¢ then three alternative functions used:\n‚Ä¢ message encryption ‚Äì symmetric\n‚Ä¢ message authentication code (MAC)\n‚Ä¢ digital signature\n\n\nPage 167:\nMessage encryption\n‚Ä¢ Symmetric message encryption by itself also provides a measure of \nauthentication\n‚Ä¢ if symmetric encryption is used then:\n‚Ä¢ receiver knows sender must have created it\n‚Ä¢ since only sender and receiver know key used\n‚Ä¢ know content cannot be altered\n\n\nPage 168:\nHomework 1 questions\n‚Ä¢ Symmetric Block Cypher provides authentication and confidentiality\n‚Ä¢ Ans: True\n\n\nPage 169:\nMessage encryption\n‚Ä¢ if public-key encryption is used:\n‚Ä¢ encryption provides no confidence of sender\n‚Ä¢ since anyone potentially knows public-key\n‚Ä¢ so, need to recognize corrupted messages\n‚Ä¢ however, if \n‚Ä¢ sender signs message using their private-key\n‚Ä¢ then encrypts with recipients‚Äô public key\n‚Ä¢ have both secrecy and authentication\n‚Ä¢ but at cost of two public-key uses on message\n\n\nPage 170:\nReasons to avoid encryption authentication\n‚Ä¢ Encryption software is quite slow\n‚Ä¢ Encryption hardware costs are nonnegligible\n‚Ä¢ Encryption hardware is optimized toward large data sizes\n‚Ä¢ An encryption algorithm may be protected by a patent\n\n\nPage 171:\nHash Function\n\n\nPage 172:\nHash functions\n‚Ä¢ Hash function: h = H(M)\n‚Ä¢ M can be of any size \n‚Ä¢ h is always of fixed size \n‚Ä¢ Typically, h << size(M) \n\n\nPage 173:\nOne use case - using hash function\n‚Ä¢ Initialization: A and B share a \ncommon secret, SAB\n‚Ä¢ Message, M\n‚Ä¢ A calculates MDM = H (SAB || M)\n‚Ä¢ B recalculates MD‚ÄôM, and check\n‚Ä¢ MD‚ÄôM = MDM\n\n\nPage 174:\nRequirements for secure hash functions\n‚Ä¢ 1. can be applied to any sized message M\n‚Ä¢ 2. produces fixed-length output h\n‚Ä¢ 3. is easy to compute h=H(M) for any message M\n‚Ä¢ 4. given h is infeasible to find x s.t. H(x)=h\n‚Ä¢ one-way property or preimage resistance\n‚Ä¢ 5. given x is infeasible to find x‚Äô",
    "chunk_order_index": 9,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-8ffd3d6a9f509409e8f027725cc62b79": {
    "tokens": 1200,
    "content": "MD‚ÄôM = MDM\n\n\nPage 174:\nRequirements for secure hash functions\n‚Ä¢ 1. can be applied to any sized message M\n‚Ä¢ 2. produces fixed-length output h\n‚Ä¢ 3. is easy to compute h=H(M) for any message M\n‚Ä¢ 4. given h is infeasible to find x s.t. H(x)=h\n‚Ä¢ one-way property or preimage resistance\n‚Ä¢ 5. given x is infeasible to find x‚Äô s.t. H(x‚Äô)=H(x)\n‚Ä¢ weak collision resistance or second pre-image resistant\n‚Ä¢ 6. infeasible to find any pair of x,x‚Äô s.t. H(x‚Äô)=H(x)\n‚Ä¢ strong collision resistance\n\n\nPage 175:\nHash Function: Collision Resistance\n‚Ä¢ Collision: Two different inputs with the same output\n‚Ä¢ x ‚â† x' and H(x) = H(x')\n‚Ä¢ Can we design a hash function with no collisions?\n‚Ä¢ No, because there are more inputs than outputs (pigeonhole principle)\n‚Ä¢ However, we want to make finding collisions infeasible for an attacker\n‚Ä¢ Collision resistance: It is infeasible to (i.e. no polynomial time attacker \ncan) find any pair of inputs x' ‚â† x such that H(x) = H(x')\n\n\nPage 176:\nSecure hash function\n‚Ä¢ A hash function that satisfies the first five properties is referred to as \na weak hash function\n‚Ä¢ Security: random/unpredictability, no predictable patterns for how \nchanging the input affects the output\n‚Ä¢ Changing 1 bit in the input causes the output to be completely different\n‚Ä¢ Also called ‚Äúrandom oracle‚Äù assumption\n\n\nPage 177:\nSecure hash function\n‚Ä¢ A hash function that satisfies the first five properties is referred to as \na weak hash function\n‚Ä¢ Security: random/unpredictability, no predictable patterns for how \nchanging the input affects the output\n‚Ä¢ Changing 1 bit in the input causes the output to be completely different\n‚Ä¢ Also called ‚Äúrandom oracle‚Äù assumption\n‚Ä¢ A message digest\n‚Ä¢ a cryptographic hash function containing a string of digits created by a one-\nway hashing formula\n‚Ä¢ provides data integrity\n‚Ä¢ Examples: SHA-1 (Secure Hash Algorithm 1), SHA-2, SHA-3, MD5\n\n\nPage 178:\nHash Function: Examples\n‚Ä¢ MD5\n‚Ä¢ Output: 128 bits\n‚Ä¢ Security: Completely broken\n‚Ä¢ SHA-1\n‚Ä¢ Output: 160 bits\n‚Ä¢ Security: Completely broken in 2017\n‚Ä¢ Was known to be weak before 2017, but still used sometimes\n‚Ä¢ SHA-2\n‚Ä¢ Output: 256, 384, or 512 bits (sometimes labeled SHA-256, SHA-384, SHA-512)\n‚Ä¢ Not currently broken, but some variants are vulnerable to a length extension attack\n‚Ä¢ Current standard\n‚Ä¢ SHA-3 (Keccak)\n‚Ä¢ Output: 256, 384, or 512 bits\n‚Ä¢ Current standard (not meant to replace SHA-2, just a different construction)\n\n\nPage 179:\nLength Extension Attacks\n‚Ä¢ Length extension attack: Given H(x) and the length of x, but not x, an \nattacker can create H(x || m) for any m of the attacker‚Äôs choosing\n‚Ä¢ Length extension attack - Wikipedia\n‚Ä¢ SHA-256 (256-bit version of SHA-2) is vulnerable\n‚Ä¢ SHA-3 is not vulnerable\n\n\nPage 180:\nLength Extension Attacks\n‚Ä¢ Length extension attack: Given H(x) and the length of x, but not x, an \nattacker can create H(x || m) for any m of the attacker‚Äôs choosing\n‚Ä¢ Length extension attack - Wikipedia\n‚Ä¢ SHA-256 (256-bit version of SHA-2) is vulnerable\n‚Ä¢ SHA-3 is not vulnerable\n\n\nPage 181:\n\n\nPage 182:\nDoes hashes provide integrity?\n‚Ä¢ It depends on your threat model\n‚Ä¢ Scenario\n‚Ä¢ Mozilla publishes a new version of Firefox on some download servers\n‚Ä¢ Alice downloads the program binary\n‚Ä¢ How can she be sure that nobody tampered with the program?\n‚Ä¢ Idea: use cryptographic hashes\n‚Ä¢ Mozilla hashes the program binary and publishes the hash on its website\n‚Ä¢ Alice hashes the binary she downloaded and checks that it matches the hash on the website\n‚Ä¢ If Alice downloaded a malicious program, the hash would not match (tampering detected!)\n‚Ä¢ An attacker can‚Äôt create a malicious program with the same hash (collision resistance)\n‚Ä¢ Threat model: We assume the attacker cannot modify the hash on the website\n‚Ä¢ We have integrity, as long as we can communicate the hash securely\n\n\nPage 183:\nDo hashes provide integrity?\n‚Ä¢ It depends on your threat model\n‚Ä¢ Scenario\n‚Ä¢ Alice and Bob want to communicate over an insecure channel\n‚Ä¢ David might tamper with messages\n‚Ä¢ Idea: Use cryptographic hashes\n‚Ä¢ Alice sends her message with a cryptographic hash over the channel\n‚Ä¢ Bob receives the message and computes a hash on the message\n‚Ä¢ Bob checks that the hash he computed matches the hash sent by Alice\n‚Ä¢ Threat model: David can modify the message and the hash\n‚Ä¢ No integrity!\n\n\nPage 184:\nMan-in-the-middle attack\nAlice\nM‚Äô\nMD‚Äô\nM\nMD\nM\nMD\nM‚Äô\nMD‚Äô\nBob\nDavid\n\n\nPage 185:\nDo hashes provide integrity? \n‚Ä¢ It depends on your threat model\n‚Ä¢ If the attacker can modify the hash, hashes don‚Äôt provide integrity\n‚Ä¢ Main issue: Hashes are unkeyed functions\n‚Ä¢ There is no secret key being used as input, so any attacker can compute a \nhash on any value\n\n\nPage 186:\nSolutions\n‚Ä¢ A message digest created using a secret symmetric key is known as a \nMessage Authentication Code (MAC), because it can provide \nassurance that the message has not been modified\n‚Ä¢ The sender can also generate",
    "chunk_order_index": 10,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-5437ac01b94e6c09c113841398864d3f": {
    "tokens": 1200,
    "content": "model\n‚Ä¢ If the attacker can modify the hash, hashes don‚Äôt provide integrity\n‚Ä¢ Main issue: Hashes are unkeyed functions\n‚Ä¢ There is no secret key being used as input, so any attacker can compute a \nhash on any value\n\n\nPage 186:\nSolutions\n‚Ä¢ A message digest created using a secret symmetric key is known as a \nMessage Authentication Code (MAC), because it can provide \nassurance that the message has not been modified\n‚Ä¢ The sender can also generate a message digest and then encrypt the \ndigest using the private key of an asymmetric key pair, forming a \ndigital signature. The signature must then be verified by the receiver \nthrough comparing it with a locally generated digest\n\n\nPage 187:\nHashes: Summary\n‚Ä¢ Map arbitrary-length input to fixed-length output\n‚Ä¢ Output is deterministic\n‚Ä¢ Security properties\n‚Ä¢ One way: Given an output y, it is infeasible to find any input x such that H(x) = y.\n‚Ä¢ Second preimage resistant: Given an input x, it is infeasible to find another input x' ‚â† \nx such that H(x) = H(x').\n‚Ä¢ Collision resistant: It is infeasible to find any pair of inputs x' ‚â† x such that H(x) = \nH(x‚Äô).\n‚Ä¢ Randomized output\n‚Ä¢ Some hashes are vulnerable to length extension attacks\n‚Ä¢ Hashes don‚Äôt provide integrity (unless you can publish the hash securely)\n\n\nPage 188:\nMessage Authentication Code\n\n\nPage 189:\nMessage authentication code (MAC)\n‚Ä¢ generated by an algorithm that creates a small fixed-sized block\n‚Ä¢ depending on both message and some key\n‚Ä¢ not be reversible\n‚Ä¢ MACM = F(KAB, M)\n‚Ä¢ appended to message as a signature\n‚Ä¢ receiver performs same computation on message and checks it \nmatches the MAC\n‚Ä¢ provides assurance that message is unaltered and comes from sender\n\n\nPage 190:\nMACs: Usage\n‚Ä¢ Alice wants to send M to Bob, but doesn‚Äôt want David to tamper with it\n‚Ä¢ Alice sends M and T = MAC(K, M) to Bob\n‚Ä¢ Bob receives M and T\n‚Ä¢ Bob computes MAC(K, M) and checks that it matches T\n‚Ä¢ If the MACs match, Bob is confident the message has not been \ntampered with (integrity)\n\n\nPage 191:\nMACs: Definition\n‚Ä¢ Two parts:\n‚Ä¢ KeyGen() ‚Üí K: Generate a key K\n‚Ä¢ MAC(K, M) ‚Üí T: Generate a tag T for the message M using key K\n‚Ä¢ Inputs: A secret key and an arbitrary-length message\n‚Ä¢ Output: A fixed-length tag on the message\n‚Ä¢ Properties\n‚Ä¢ Correctness: Determinism\n‚Ä¢ Note: Some more complicated MAC schemes have an additional Verify(K, M, T) function \nthat don‚Äôt require determinism, but this is out of scope\n‚Ä¢ Efficiency: Computing a MAC should be efficient\n‚Ä¢ Security: existentially unforgeable under chosen plaintext attack\n\n\nPage 192:\nMid-term Exam\n‚Ä¢ Nov. 6, 2024 (Wednesday), 12:00 pm ‚Äì 12:50 pm, in class\n‚Ä¢ Closed book, but you're allowed to bring one cheat sheet (1 A4-sized \npaper)\n‚Ä¢ Chapter 1 ‚Äì 3\n‚Ä¢ Will have a review class on Nov. 1st , during class\n\n\nPage 193:\nExistentially unforgeable\n‚Ä¢ A secure MAC is existentially unforgeable: without the key, an \nattacker cannot create a valid tag on a message\n‚Ä¢ David cannot generate MAC(K, M') without K\n‚Ä¢ David cannot find any M' ‚â† M such that MAC(K, M') = MAC(K, M)\n\n\nPage 194:\nExample: HMAC\n‚Ä¢ issued as RFC 2104 [1]\n‚Ä¢ has been chosen as the mandatory-to-implement MAC for IP Security\n‚Ä¢ Used in Transport Layer Security (TLS) and Secure Electronic \nTransaction (SET)\n[1] ‚ÄúHMAC: Keyed-Hashing for Message Authentication‚Äù, RFC 2104, https://datatracker.ietf.org/doc/html/rfc2104\n\n\nPage 195:\nHMAC(K, M)\n‚Ä¢ will produce two keys to increase security\n‚Ä¢ If key is longer than the desired size, we can hash it first, but be \ncareful with using keys that are too much smaller, they have to have \nenough randomness in them\n‚Ä¢ Output H[(K+ ‚äïopad) || H[(K+ ‚äïipad) || M]]\n\n\nPage 196:\nExample: HMAC\n‚Ä¢ HMAC(K, M):\n‚Ä¢ Output H[(K+ ‚äïopad) || H[(K+ ‚äïipad) || M]]\n‚Ä¢ Use K to derive two different keys\n‚Ä¢ opad (outer pad) is the hard-coded byte 0x5c repeated until it‚Äôs the same \nlength as K+\n‚Ä¢ ipad (inner pad) is the hard-coded byte 0x36 repeated until it‚Äôs the same \nlength as K+\n‚Ä¢ As long as opad and ipad are different, you‚Äôll get two different keys\n‚Ä¢ For paranoia, the designers chose two very different bit patterns, even though \nthey theoretically need only differ in one bit\n\n\nPage 197:\nHMAC \nA\nB\nA ‚®ÅB\n0 \n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n0\nK+ = !H ùêæ \nùêæ ùëñùë† ùëôùëéùëüùëîùëíùëü ùë°‚Ñéùëéùëõ ùëèùëôùëúùëêùëò ùë†ùëñùëßùëí",
    "chunk_order_index": 11,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-47b0b899ac51dc078a3484b91ef92652": {
    "tokens": 1200,
    "content": "0 \n0\n0\n0\n1\n1\n1\n0\n1\n1\n1\n0\nK+ = !H ùêæ \nùêæ ùëñùë† ùëôùëéùëüùëîùëíùëü ùë°‚Ñéùëéùëõ ùëèùëôùëúùëêùëò ùë†ùëñùëßùëí\nùêæ \nùëúùë°‚Ñéùëíùëüùë§ùëñùë†ùëí\nipad = 00110110 , repeat b/8 times\nopad = 01011100, repeat b/8 times\n\n\nPage 198:\nHMAC procedure\n‚Ä¢ Step 1: Append zeros to the left end of K to create a b-bit string K+ (e.g., if K \nis of length 160 bits and b = 512, then K will be appended with 44 zero \nbytes); \n‚Ä¢ Step 2: XOR (bitwise exclusive-OR) K+ with ipad to produce the b-bit block \nSi;\n‚Ä¢ Step 3: Append M to Si;\n‚Ä¢ Step 4: Apply H to the stream generated in step 3; \n‚Ä¢ Step 5: XOR K+ with opad to produce the b-bit block So;\n‚Ä¢ Step 6: Append the hash result from step 4 to So;\n‚Ä¢ Step 7: Apply H to the stream generated in step 6 and output the result. \n\n\nPage 199:\nHMAC Properties\n‚Ä¢ HMAC(K, M) = H[(K+ ‚äïopad) || H((K+ ‚äïipad) || M]]\n‚Ä¢ HMAC is a hash function, so it has the properties of the underlying \nhash too\n‚Ä¢ It is collision resistant\n‚Ä¢ Given HMAC(K, M), an attacker can‚Äôt learn M ‚Äì one way\n‚Ä¢ If the underlying hash is secure, HMAC doesn‚Äôt reveal M, but it is still \ndeterministic\n‚Ä¢ You can‚Äôt verify a tag T if you don‚Äôt have K\n‚Ä¢ This means that an attacker can‚Äôt brute-force the message M without \nknowing K\n\n\nPage 200:\nMACs: Summary\n‚Ä¢ Inputs: a secret key and a message\n‚Ä¢ Output: a tag on the message\n‚Ä¢ A secure MAC is unforgeable: Even if David can trick Alice into \ncreating MACs for messages that David chooses, David cannot create \na valid MAC on a message that she hasn't seen before\n‚Ä¢ Example: HMAC(K, M) = H((K+ ‚äïopad) || H((K+ ‚äïipad) || M))\n‚Ä¢ MACs do not provide confidentiality\n\n\nPage 201:\nDo MACs provide integrity? \n‚Ä¢ Do MACs provide integrity?\n‚Ä¢ Yes. An attacker cannot tamper with the message without being detected\n‚Ä¢ Do MACs provide authenticity?\n‚Ä¢ It depends on your threat model\n‚Ä¢ If only two people have the secret key, MACs provide authenticity: it has a \nvalid MAC, and it‚Äôs not from me, so it must be from the other person\n‚Ä¢ More than one secret key, If a message has a valid MAC, you can be sure it \ncame from someone with the secret key, but you can‚Äôt narrow it down to one \nperson\n‚Ä¢ Do MACs provide confidentiality?\n\n\nPage 202:\nAuthenticated Encryption\n\n\nPage 203:\nAuthenticated Encryption: Definition\n‚Ä¢ Authenticated encryption (AE): A scheme that simultaneously \nguarantees confidentiality and integrity (and authenticity, depending \non your threat model) on a message\n‚Ä¢ Two ways of achieving authenticated encryption:\n‚Ä¢ Combine schemes that provide confidentiality with schemes that provide \nintegrity\n‚Ä¢ Use a scheme that is designed to provide confidentiality and integrity\n\n\nPage 204:\nAuthenticated Encryption: Definition\n‚Ä¢ Authenticated encryption (AE): A scheme that simultaneously \nguarantees confidentiality and integrity (and authenticity, depending \non your threat model) on a message\n‚Ä¢ Two ways of achieving authenticated encryption:\n‚Ä¢ Combine schemes that provide confidentiality with schemes that provide \nintegrity\n‚Ä¢ Use a scheme that is designed to provide confidentiality and integrity\n\n\nPage 205:\nScratchpad: Let‚Äôs design it together\n‚Ä¢ You can use:\n‚Ä¢ An encryption scheme: Enc(K, M) and Dec(K, M)\n‚Ä¢ An unforgeable MAC scheme (e.g. HMAC): MAC(K, M)\n‚Ä¢ First attempt: Alice sends Enc(K1, M) and MAC(K2, M)\n‚Ä¢ Integrity? Yes, attacker can‚Äôt tamper with the MAC\n‚Ä¢ Confidentiality? No, the MAC is not secure\n‚Ä¢ Idea 1: Let‚Äôs compute the MAC on the ciphertext instead of the plaintext:\nEnc(K1, M) and MAC(k2, Enc(K1, M))\n‚Ä¢ Integrity? Yes, attacker can‚Äôt tamper with the MAC\n‚Ä¢ Confidentiality? Yes, the MAC might leak info about the ciphertext, but that‚Äôs okay\n‚Ä¢ Idea 2: Let‚Äôs encrypt the MAC too: Enc(K1, M || MAC(K2, M))\n‚Ä¢ Integrity? Yes, attacker can‚Äôt tamper with the MAC\n‚Ä¢ Confidentiality? Yes, everything is encrypted\n\n\nPage 206:\nMAC-then-Encrypt or Encrypt-then-MAC?\n‚Ä¢ Method 1: Encrypt-then-MAC\n‚Ä¢ First compute Enc(K1, M)\n‚Ä¢ Then MAC the ciphertext: MAC(K2, Enc(K1, M))\n‚Ä¢ Method 2: MAC-then-encrypt\n‚Ä¢ First compute MAC(K2, M)\n‚Ä¢ Then encrypt the message and the MAC together: Enc(k1, M || MAC(K2, M))\n‚Ä¢ Which is better?\n‚Ä¢ In theory, both are secure if applied properly\n‚Ä¢",
    "chunk_order_index": 12,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-d5fdaef73d4c1d8b1f19827dbb97a3fc": {
    "tokens": 1200,
    "content": "-then-MAC?\n‚Ä¢ Method 1: Encrypt-then-MAC\n‚Ä¢ First compute Enc(K1, M)\n‚Ä¢ Then MAC the ciphertext: MAC(K2, Enc(K1, M))\n‚Ä¢ Method 2: MAC-then-encrypt\n‚Ä¢ First compute MAC(K2, M)\n‚Ä¢ Then encrypt the message and the MAC together: Enc(k1, M || MAC(K2, M))\n‚Ä¢ Which is better?\n‚Ä¢ In theory, both are secure if applied properly\n‚Ä¢ MAC-then-encrypt has a flaw: You don‚Äôt know if tampering has occurred until after \ndecrypting\n‚Ä¢ Attacker can supply arbitrary tampered input, and you always have to decrypt it\n‚Ä¢ Passing attacker-chosen input through the decryption function can cause side-channel leaks\n‚Ä¢ Always use encrypt-then-MAC because it‚Äôs more robust to mistakes\n\n\nPage 207:\nTLS 1.0 ‚ÄúLucky 13‚Äù Attack\n‚Ä¢ TLS: A protocol for sending encrypted and authenticated messages over the \nInternet\n‚Ä¢ TLS 1.0 uses MAC-then-encrypt: Enc(k1, M || MAC(k2, M))\n‚Ä¢ The encryption algorithm is AES-CBC\n‚Ä¢ The Lucky 13 attack abuses MAC-then-encrypt to read encrypted messages\n‚Ä¢ Guess a byte of plaintext and change the ciphertext accordingly\n‚Ä¢ The MAC will error, but the time it takes to error is different depending on if the \nguess is correct\n‚Ä¢ Attacker measures how long it takes to error in order to learn information about \nplaintext\n‚Ä¢ TLS will send the message again if the MAC errors, so the attacker can guess \nrepeatedly\n‚Ä¢ Takeaways\n‚Ä¢ Side channel attack: The algorithm is proved secure, but poor implementation made \nit vulnerable\n‚Ä¢ Always encrypt-then-MAC\n\n\nPage 208:\nAuthenticated Encryption: Summary\n‚Ä¢ Authenticated encryption: A scheme that simultaneously guarantees \nconfidentiality and integrity (and authenticity) on a message\n‚Ä¢ First approach: Combine schemes that provide confidentiality with \nschemes that provide integrity and authenticity\n‚Ä¢ MAC-then-encrypt: Enc(K1, M || MAC(K2, M))\n‚Ä¢ Encrypt-then-MAC: MAC(K2, Enc(K1, M))\n‚Ä¢ Always use Encrypt-then-MAC because it's more robust to mistakes\n\n\nPage 209:\nDigital Signature\n\n\nPage 210:\nDigital Signatures\n‚Ä¢ NIST FIPS PUB 186-4 - the result of a cryptographic transformation of \ndata that, when properly implemented, provides a mechanism for \nverifying origin authentication, data integrity, and signatory non-\nrepudiation\n‚Ä¢ Based on asymmetric keys\n\n\nPage 211:\nDigital Signatures\n‚Ä¢ Asymmetric cryptography is good because we don‚Äôt need to share a \nsecret key\n‚Ä¢ Digital signatures are the asymmetric way of providing \nintegrity/authenticity to data\n‚Ä¢ Assume that Alice and Bob can communicate public keys without \nDavid interfering\n\n\nPage 212:\nDigital Signatures: Definition\n‚Ä¢ Three parts:\n‚Ä¢ KeyGen() ‚Üí PK, SK: Generate a public/private keypair, where PK is the verify (public) key, and SK\nis the signing (secret) key\n‚Ä¢ Sign(SK, M) ‚Üí sig: Sign the message M using the signing key SK to produce the signature sig\n‚Ä¢ Verify(PK, M, sig) ‚Üí {0, 1}: Verify the signature sig on message M using the verify key PK and \noutput 1 if valid and 0 if invalid\n‚Ä¢ Properties:\n‚Ä¢ Correctness: Verification should be successful for a signature generated over any message\n‚Ä¢ Verify(PK, M, Sign(SK, M)) = 1 for all PK, SK ‚Üê KeyGen() and M\n‚Ä¢ Efficiency: Signing/verifying should be fast\n‚Ä¢ Security: Same as for MACs except that the attacker also receives PK\n‚Ä¢ Namely, no attacker can forge a signature for a message\n\n\nPage 213:\nRSA Signature\n‚Ä¢ KeyGen():\n‚Ä¢ Randomly pick two large primes, p and q\n‚Ä¢ Compute n = pq\n‚Ä¢ n is usually between 2048 bits and 4096 bits long\n‚Ä¢ Choose e\n‚Ä¢ Requirement: e is relatively prime to (p - 1)(q - 1)\n‚Ä¢ Requirement: 2 < e < (p - 1)(q - 1)\n‚Ä¢ Compute d = e-1 mod (p - 1)(q - 1)\n‚Ä¢ Public key: n and e\n‚Ä¢ Private key: d\n\n\nPage 214:\nA Short Quiz\n‚Ä¢ We will have a short quiz on Wednesday, Oct. 30, in class \n‚Ä¢ A short quiz will cover the materials taught that day. \n\n\nPage 215:\nRSA Signatures\n‚Ä¢ Sign(d, M):\n‚Ä¢ Compute H(M)d mod n\n‚Ä¢ Verify(e, n, M, sig)\n‚Ä¢ Verify that H(M) ‚â° sige mod n\n\n\nPage 216:\nRSA Digital Signature Algo\nStep1: Generate a hash value, or message digest, \nmHash from the message M to be signed \nStep2: Pad mHash with a constant value padding1 and \npseudorandom value salt to form M‚Äô \nStep3: Generate hash value H from M‚Äô\nStep4: Generate a block DB consisting of a constant \nvalue padding 2 and salt\nStep5: Use the mask generating function MGF, which \nproduces a randomized out-put from input H of the \nsame length as DB\nStep 6: Create the encoded message (EM) block by \npadding H with the hexadecimal constant bc and the \nXOR of DB and output of MGF\nStep 7: Encrypt EM with RSA using the signer‚Äôs private \nkey \n\n\nPage 217:\nRSA Signatures: Correctness\nTheorem: sige ‚â° H(M) mod N\nProof:\nsige = [ÔøΩ",
    "chunk_order_index": 13,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  },
  "chunk-ad64d4e60b3138a59660a1c37d76448c": {
    "tokens": 835,
    "content": ", which \nproduces a randomized out-put from input H of the \nsame length as DB\nStep 6: Create the encoded message (EM) block by \npadding H with the hexadecimal constant bc and the \nXOR of DB and output of MGF\nStep 7: Encrypt EM with RSA using the signer‚Äôs private \nkey \n\n\nPage 217:\nRSA Signatures: Correctness\nTheorem: sige ‚â° H(M) mod N\nProof:\nsige = [ùêªùëÄùëë ]ùëí ùëöùëúùëë ùëÅ\n= ùêª(ùëÄ)\"# mod N\n\n\nPage 218:\nRSA Signatures: Correctness\nTheorem: sige ‚â° H(M) mod N\nProof:\nsige = [ùêªùëÄùëë ]ùëí ùëöùëúùëë ùëÅ\n= ùêª(ùëÄ)\"# mod N\n= ùêª(ùëÄ)$% & '(   mod N\n=  [ùêª(ùëÄ)%(&)]$- ùêªùëÄ mod N\n= H(M)    mod N\n\n\nPage 219:\nRSA Digital Signature: Security\n‚Ä¢ Necessary hardness assumptions:\n‚Ä¢ Factoring hardness assumption: Given n large, it is hard to find primes pq = n\n‚Ä¢ Discrete logarithm hardness assumption: Given n large, hash, and hashd mod \nn, it is hard to find d\n‚Ä¢ Salt also adds security\n‚Ä¢ Even the same message and private key will get different signatures\n\n\nPage 220:\nHybrid Encryption\n‚Ä¢ Issues with public-key encryption\n‚Ä¢ Notice: We can only encrypt small messages because of the modulo operator\n‚Ä¢ Notice: There is a lot of math, and computers are slow at math\n‚Ä¢ Result: We don‚Äôt use asymmetric for large messages\n‚Ä¢ Hybrid encryption: Encrypt data under a randomly generated key K\nusing symmetric encryption, and encrypt K using asymmetric \nencryption\n‚Ä¢ EncAsym(PK, K); EncSym(K, large message)\n‚Ä¢ Benefit: Now we can encrypt large amounts of data quickly using symmetric \nencryption, and we still have the security of asymmetric encryption\n\n\nPage 221:\nHomework (Textbook) ‚Äì no submission\n‚Ä¢ Review Question: 3.1, 3.2, 3.3, 3.4, 3.5, 3.6\n‚Ä¢ Problems: \n‚Ä¢ prove correctness of RSA digital signature\n‚Ä¢ 3.14 & 3.15\n\n\nPage 222:\nHomework 2 - individual\n‚Ä¢ For Chapter 3\n‚Ä¢ Deadline Friday, Nov. 1 before class\n‚Ä¢ 10% penalty per day for late submission\n\n\nPage 223:\nThank you!\n\n\nPage 224:\nNetwork Security\nChapter 4\n\n\nPage 225:\nKey Distribution\n\n\nPage 226:\nSymmetric Key Distribution and User Authentication\n4.2 \n\n\nPage 227:\nWays to achieve symmetric key distribution\n‚Ä¢ A key could be selected by A and physically delivered to B\n‚Ä¢ A third party could select the key and physically deliver it to A and B \n‚Ä¢ If A and B have previously and recently used a key, one party could \ntransmit the new key to the other, using the old key to encrypt the \nnew key \n‚Ä¢ If A and B each have an encrypted connection to a third-party C, C \ncould deliver a key on the encrypted links to A and B \n\n\nPage 228:\nTerminologies\n‚Ä¢ Session key\n‚Ä¢ Permanent key\n‚Ä¢ key distribution center (KDC) \n‚Ä¢ third party authority, centralized infrastructure\n‚Ä¢ give permissions for two parties to communicate\n\n\nPage 229:\nDiffie-Hellman Key Exchange\nSection 3.5\n\n\nPage 230:\nIn class quiz on Wednesday\n‚Ä¢ We will have a short quiz on Wednesday, Oct. 30, in class\n‚Ä¢ A short quiz will cover the materials taught that day.\n‚Ä¢ Please be on time for class to avoid missing the quiz questions.",
    "chunk_order_index": 14,
    "full_doc_id": "doc-cd13965b956320f584e158d31cea3e47"
  }
}